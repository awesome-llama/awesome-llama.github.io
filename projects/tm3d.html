<!DOCTYPE html>
<html>
<head>
  <title>The Mast 3D</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato">
</head>

<body>
<div class="navbar">
    <div>
      <a href="/" class="navbtn"><div class="navbtnlink">Home</div></a>
      <a href="/articles" class="navbtn"><div class="navbtnlink">Articles</div></a>
      <a href="/projects" class="navbtn"><div class="navbtnlink">Projects</div></a>
      <a href="/utils" class="navbtn"><div class="navbtnlink">Utilities</div></a>
    </div>
  </div>

  <div class="content">
    <h1>The Mast 3D</h1>
    <hr>
    <p>Play it here: 
      <b><a href="https://turbowarp.org/861541218">TurboWarp</a></b> |  
      <b><a href="https://scratch.mit.edu/projects/861541218">Scratch</a></b> |  
      <b><a href="/projects/the_mast">Standalone (TW packager)</a></b>
    </p>
    
    <img src=https://cdn2.scratch.mit.edu/get_image/project/861541218_480x360.png>
    <br>
    <p>A textured 3D game set on a fictional planet. Explore highly detailed environments and structures and uncover the events that took place. Inspired by <a href="https://en.wikipedia.org/wiki/Infra_(video_game)">Infra</a> and <a href="https://en.wikipedia.org/wiki/Rain_World">Rain World</a>, among other things.</p>
    <p>Controls can be set inside the project, by default it is WASD and mouse click/drag.</p>
    <br>
    <h2>General technical details</h2>
    <ul>
      <li>Z-up orientation, identical to Blender. Camera faces -Z (directly down) and up/down is around the X axis as well. Camera roll is not supported as it's not needed and just a waste of performance in this use case.</li>
      <li>Everything is Metric/SI.</li>
      <li>Rendering uses a textured tri filler created by <a href="https://scratch.mit.edu/projects/826059940/">Bambozzle</a>. This filler uses a depth buffer. No sorting is used.</li>
      <li>A stripped-down version of the project exists as <a href="https://scratch.mit.edu/projects/861549676/">Nuclear Power Plant [3D]</a>. It is recommended you look at that first if you want to learn more or even develop your own games with it. <a href="https://awesome-llama.github.io/assets/npp3d/nuclear_power_plant.blend">You can download the Blender file for it to use as a reference.</a> Warning: Make sure you respect the object naming syntax required, older versions of Blender will not export the names correctly. Also make sure you triangulate the geometry.</li>
      <li>The text renderer can be found here: <a href="https://scratch.mit.edu/projects/735937335/">https://scratch.mit.edu/projects/735937335/</a> I made my own because I was not satisfied with other PTEs available. None of them can render text at small sizes like mine. Many are also bloated with features I would never use.</li>
    </ul>

    <br>
    <h2>Textures</h2>
    <p>This project uses a <a href="https://scratch.mit.edu/projects/788861757/">custom text-based image format</a> developed by myself, with help from <a href="https://scratch.mit.edu/projects/693020370/">Arctenik</a>.
    This was necessary due to the fact that the textures take up a lot more space than what is allowed to be stored in a Scratch project's <span class="code">project.json</span>, which has a limit of 5MB, including scripts, vars, and anything else necessary to run the project.
    Costumes and audio are stored separately and have their own limit of 10MB each, no limit on total count. This image format compresses 24-bit RGB images which you can read about in more detail in the linked project description.</p>
    <p>The project size limit leaves few options for storing the needed textures. Even with compression, the full-res textures do not fit. I provide a low-res version in the project that can be loaded at any time but the full-res textures must either be scanned or pasted in via a text input box.
    The pipeline for importing full-res textures can be seen below. Half-res textures are the exact same except there is no branch for image scanning as it doesn't need it.</p>
    <img src="/img/TM3D_texture_data_flow.png">
    <p>Additionally it must be noted that an exception is made for the starting Pod region. The player doesn't get to choose the texture quality for it, the full-res texture is automatically loaded from a separate variable storing it.</p>

    <p>A compressed texture by itself is pretty useless, it's just a stream of pixel colours. To make it usable, "metadata" is included and this is handled in the above diagram too. The format for the actual string accepted by the project is (spaces separate values):</p>
    <p class="code">[texture_name] [number_of_pixels_total] [texture_width] [texture_height] [checksum] [compresed_data]</p>
    <p>This repeats for every texture needed.</p>
    <p>The checksum is used to ensure texture data is intact. It is just a sum of the compressed data stream with each character being counted using its index in a list (matches the ordering of ASCII except with different indices, ! is 1).</p>
    <p>Here's one of the textures in a format that can be seen: <a href="/img/region_start_off.png">region_start_off.png</a></p>
    <p>If you want the texture data in text form, go here: <a href="/tex">The Mast Textures</a></p>
    
    <br>
    <h2>Models</h2>
    <p>The world was created in Blender. I have a single .blend file storing everything and this gets exported to .obj which the project is able to read. Inside the project is a list called WORLD.obj, this is the file with lines as seprate items.</p>
    <p>There is a very important naming system being used to specify what each mesh is responsible for:</p>
    <p class="code">[region name],[FL/VZ/DY],[room or object subname(if not FL)],[BB (if not FL)]
      <br>FL is floor
      <br>VZ is static visible geometry
      <br>DY is dynamic geometry (things that can be moved such as doors)
      <br>BB is bounding box and is used by static geometry for only rendering when unoccluded. Dynamic geometry may also use it but I don't bother.</p>
    Here are examples:
    <p class="code">
      start_off,VZ,corridor
      <br>walkways,VZ,lower,BB
      <br>surface,DY,surface_keycard
      <br>drill,VZ
      <br>track,FL
    </p>
    <p>There is only 1 floor per region, which is fine as it's not slow and it makes the collision wall generation (for the player's movement) simple.
      Walls are generated by finding exposed edges (edges that are not shared by 2 adjacent triangles). A line segment is added. Actually, the walls are geometrically <a href="https://en.wikipedia.org/wiki/Stadium_(geometry)">stadia</a> extruded along the Z axis.
    </p>
    <p>Regions are split into rooms for improved performance. Rooms are separate objects. The default main room which is always visible will not have a subname, it will just be <span class="code">[region name]_VZ</span>. Any other room must be accompanied by a bounding box to be visible. The bounding box is calculated by the bounds of the tris of the object and can be of whatever you want. I use rectangular prisms to make visualisation easier. 
      Dynamic geometry does not need a bounding box, it will always be visible. A bounding box of size infinity is created automatically for the main room and dynamic geometry.
    </p>
  
    <br>
    <h2>Player movement</h2>
    <p>This game uses a fixed update rate of 120Hz for player movement. This is to ensure that collisions occur correctly and are deterministic. The timer also is updated with this.
      Each game frame, a discrete number of movement ticks are run. At 60 FPS, that would be twice. 
      Limitations are in place just in case unexpected data is found, at most 20 ticks can occur each frame (equivalent to 6 FPS) and past that, the player will move slower.
    </p>
    <p>The player is the camera. There is no differentiation.</p>
    <p>Movement occurs along the XY plane and Z axis separately. The player moves horizontally as needed and collisions occur in 2D on line segments. If the player is above a floor triangle, the camera will be set so it is exactly 1.65m above it (the eye height of the player).</p>
  
    <br>
    <h2>Debugging</h2>
    <p>Enable dev (developer) mode. There is a variable in the project called <span class="code">! dev</span>, which should be set to 1 to enable. By default it is set based on the username (in the <span class="code">main</span> sprite). Dev mode provides access to a bunch of developer tools and cheats, including a command system. Note that it is primarily meant for the developer of the project (of course) and does not have the same polish the playable project has. The command input box can be opened with the / key. The command syntax is <span class="code">[command name] [params]</span>. The full list of commands can be seen inside the project, in the relevant sprite.</p>
    <p>I highly recommend using TurboWarp or other scratch extensions to make use of the "debug blocks" in this project 
      (the <span class="code">log</span>, <span class="code">warn</span> and <span class="code">error</span> blocks).
      If an error occurs, it will likely be logged and give an explanation of what's known or assumed. Note that you should be using dev mode as some require it to be triggered.
    </p>
  </div>


</body>

</html>
