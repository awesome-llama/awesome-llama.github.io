<!DOCTYPE html>
<html>
<head>
  <title>The Mast 3D</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="css/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato">
</head>

<body>
<div class="navbar">
  <div>
    <a href="index.html" class="navbtn">Home</a>
  </div>
</div>

  <div class="content">
    <h1>The Mast 3D</h1>
    <hr>
    <p>Play it here: 
      <b><a href="https://turbowarp.org/861541218">TurboWarp</a></b> |  
      <b><a href="https://scratch.mit.edu/projects/861541218">Scratch</a></b> |  
      <b><a href="the_mast">Standalone (TW packager)</a></b>
    </p>
    
    <img src=https://cdn2.scratch.mit.edu/get_image/project/861541218_480x360.png>
    <br>
    <p>A textured 3D game set on a fictional planet. Explore highly detailed environments and structures and uncover the events that took place. Inspired by Infra and Rain World, among other things.</p>
    <p>Controls can be set inside the project, by default it is WASD and mouse click/drag.</p>
    <br>
    <h2>General technical details</h2>
    <ul>
      <li>Z-up orientation, identical to Blender. Camera faces -Z (directly down) and up/down is around the x axis as well. Camera roll is not supported as it's not needed and just a waste of performance in this use case.</li>
      <li>Rendering uses a textured tri filler created by <a href="https://scratch.mit.edu/projects/826059940/">Bambozzle</a>. This filler uses a depth buffer. No sorting is used.</li>
      <li>A stripped-down version of the project exists as <a href="https://scratch.mit.edu/projects/861549676/">Nuclear Power Plant [3D]</a>. It is recommended you look at that first if you want to learn more or even develop your own games with it.</li>
    </ul>

    <h2>Textures</h2>
    <p>This project uses a <a href="https://scratch.mit.edu/projects/788861757/">custom text-based image format</a> developed by myself, with help from <a href="https://scratch.mit.edu/projects/693020370/">Arctenik</a>.
    This was necessary due to the fact that the textures take up a lot more space than what is allowed to be stored in a Scratch project's <span class="code">project.json</span>, which has a limit of 5MB, including scripts, vars, and anything else necessary to run the project.
    Costumes and audio are stored separately and have their own limit of 10MB each, no limit on total count. This image format compresses 24-bit RGB images which you can read about in more detail in the linked project description.</p>
    <p>The project size limit leaves few options for storing the needed textures. Even with compression, the full-res textures do not fit. I provide a low-res version in the project that can be loaded at any time but the full-res textures must either be scanned or pasted in via a text input box.
    The pipeline for importing full-res textures can be seen below. Half-res textures are the exact same except there is no branch for image scanning as it doesn't need it.</p>
    <img src="img/TM3D_texture_data_flow.png">
    <p>Additionally it must be noted that an exception is made for the starting Pod region. The player doesn't get to choose the texture quality for it, the full-res texture is automatically loaded from a separate variable storing it.</p>

    <p>A compressed texture by itself is pretty useless, it's just a stream of pixel colours. To make it usable, "metadata" is included and this is handled in the above diagram too. The format for the actual string accepted by the project is (spaces separate values):</p>
    <p class="code">[texture_name] [number_of_pixels_total] [texture_width] [texture_height] [checksum] [compresed_data]</p>
    <p>This repeats for every texture needed.</p>
    <p>The checksum is used to ensure texture data is intact. It is just a sum of the compressed data stream with each character being counted using its index in a list (matches ASCII).</p>

    <h2>Models</h2>
    <p>The world was created in Blender. I have a single .blend file storing everything and this gets exported to .obj which the project is able to read. Inside the project is a list called WORLD.obj, this is the file with lines as seprate items.</p>
    <p>There is a very important naming system being used to specify what each mesh is responsible for:</p>
    <p class="code">[region name],[FL/VZ/DY],[room or object subname(if not FL)],[BB (if vz)]
      <br>FL is floor
      <br>VZ is static visible geometry
      <br>DY is dynamic geometry (things that can be moved such as doors)
      <br>BB is bounding box and is used by static geometry for only rendering when unoccluded.</p>
    <p>There is only 1 floor per region, which is fine as it's not slow and it makes the collision wall generation (for the player's movement) simple.
      Walls are generated by finding exposed edges (edges that are not shared by 2 adjacent triangles). A line segment is added. Actually, the walls are geometrically <a href="https://en.wikipedia.org/wiki/Stadium_(geometry)">stadia</a> extruded along the Z axis.
    </p>
    <p>Regions are split into rooms for improved performance. Rooms are separate objects. The default main room which is always visible will not have a subname, it will just be <span class="code">[region name]_VZ</span>. Any other room must be accompanied by a bounding box to be visible. The bounding box is calculated by the bounds of the tris of the object and can be of whatever you want. I use rectangular prisms to make visualisation easier. 
      Dynamic geometry does not need a bounding box, it will always be visible. A bounding box of size infinity is created automatically for the main room and dynamic geometry.
      </p>

  </div>


</body>

</html>
